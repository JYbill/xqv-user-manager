[request_definition]
#   用户名，api，方法
r = sub, obj, act
#   用户名，api，方法，允许/拒绝
r2 = sub, obj, act, eft

[policy_definition]
p = sub, obj, act
# ABAC就不一样了，这里策略的sub_rule相当于一段判断条件表达式，就这一个区别，可以看看策略文件
# obj,...,eft 与之前的一致
p2= sub_rule, obj, act, eft

[role_definition]
# 用户继承(g, xiaoqinvar, MANAGER) -> xiaoqinvar 拥有 MANAGER角色
g = _, _
# 资源集成(g2, /user/info, testApiGet) -> /user/info 属于 testApiGet资源组
g2 = _, _

[policy_effect]
# e 默认条件 -> 只要有一个条件满足了就通过
e = some(where (p.eft == allow))
# e2 自定义条件 -> 只要没有否定条件就通过，也就是说e2条件下，在策略文件中没有写任何策略，也判定为通过，因为！没有deny策略即通过！
e2 = !some(where (p.eft == deny))

[matchers]
#RABC
# 这里我请求是个对象
# 请求对象中的username要和策略文件中的一致
# 如果请求对象中的role角色为'root'则不用查策略文件，全部通过
m = g(r.sub.username, p.sub) && g2(r.obj, p.obj) && r.act == p.act || r.sub.role == 'ROOT'
#ABAC
m2 = eval(p2.sub_rule) && r2.obj == p2.obj && r2.act == p2.act && p2.eft == 'allow'
#ABAC: 当且仅当user isAdmin为true才能通过，其实完全可以做成AOP，这里只是演示效果
m3 = isRoot(r.sub.username, p.obj)
# m1 m2 m3可以理解为三个方案，m为RBAC方案，m2为ABAC方案，m3为ABAC自定义方法方案
